package com.chitieu.domain.service;

import com.chitieu.domain.model.*;
import com.chitieu.domain.repository.FriendshipRepositoryPort;
import com.chitieu.domain.repository.UserRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class FriendshipService {

    private final FriendshipRepositoryPort friendshipRepository;
    private final UserRepositoryPort userRepository;
    private final com.chitieu.domain.repository.AccountRepositoryPort accountRepositoryPort;
    private final PrivacyService privacyService;

    // ... (constructors generated by Lombok)

    // ... (other methods)

    // Helper to determine rank
    private String determineRankTier(java.math.BigDecimal wealth) {
        if (wealth == null)
            return "BRONZE";
        long value = wealth.longValue();
        if (value >= 1_000_000_000)
            return "DIAMOND";
        if (value >= 200_000_000)
            return "PLATINUM";
        if (value >= 50_000_000)
            return "GOLD";
        if (value >= 10_000_000)
            return "SILVER";
        return "BRONZE";
    }

    private FriendProfile buildFriendProfileFromUser(UUID currentUserId, User friend, FriendshipStatus status) {
        // Fetch wealth to determine rank
        // Note: This creates N+1 queries, but is acceptable for small friend lists.
        // For large lists, we should refactor to bulk fetch.
        java.math.BigDecimal totalWealth = java.math.BigDecimal.ZERO;
        try {
            Map<UUID, java.math.BigDecimal> wealthMap = accountRepositoryPort
                    .findTotalBalanceByUserIds(Collections.singletonList(friend.getId()));
            totalWealth = wealthMap.getOrDefault(friend.getId(), java.math.BigDecimal.ZERO);
        } catch (Exception e) {
            log.warn("Failed to fetch wealth for user {}", friend.getId());
        }

        return FriendProfile.builder()
                .userId(friend.getId())
                .username(friend.getUsername())
                .fullName(friend.getFullName())
                .avatar(null) // TODO: Add avatar support
                .email(friend.getEmail())
                .friendshipStatus(status)
                .mutualFriendsCount(0)
                .sharedGoalsCount(0)
                .isOnline(false)
                .rankTier(determineRankTier(totalWealth))
                .build();
    }

    @Transactional
    public Friendship sendFriendRequest(UUID fromUserId, UUID toUserId) {
        if (fromUserId.equals(toUserId)) {
            throw new IllegalArgumentException("Cannot send friend request to yourself");
        }

        userRepository.findById(toUserId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        PrivacySettings privacy = privacyService.getSettings(toUserId);
        if (!privacy.isAllowFriendRequests()) {
            throw new RuntimeException("User does not accept friend requests");
        }

        Optional<Friendship> existing = friendshipRepository.findByUserIds(fromUserId, toUserId);
        if (existing.isPresent()) {
            if (existing.get().isBlocked()) {
                throw new RuntimeException("User is blocked");
            }
            if (existing.get().isPending()) {
                throw new RuntimeException("Friend request already sent");
            }
            if (existing.get().isAccepted()) {
                throw new RuntimeException("Already friends");
            }
        }

        Friendship friendship = Friendship.builder()
                .userId(fromUserId)
                .friendId(toUserId)
                .status(FriendshipStatus.PENDING)
                .requestedBy(fromUserId)
                .requestedAt(LocalDateTime.now())
                .build();

        return friendshipRepository.save(friendship);
    }

    @Transactional
    public Friendship acceptFriendRequest(UUID userId, UUID friendId) {
        Friendship friendship = friendshipRepository.findByUserIds(userId, friendId)
                .orElseThrow(() -> new RuntimeException("Friend request not found"));

        if (friendship.getRequestedBy().equals(userId)) {
            throw new RuntimeException("You cannot accept your own friend request");
        }

        if (!friendship.isPending()) {
            throw new RuntimeException("Friend request is not in PENDING status");
        }

        Friendship accepted = Friendship.builder()
                .id(friendship.getId())
                .userId(friendship.getUserId())
                .friendId(friendship.getFriendId())
                .status(FriendshipStatus.ACCEPTED)
                .requestedBy(friendship.getRequestedBy())
                .requestedAt(friendship.getRequestedAt())
                .acceptedAt(LocalDateTime.now())
                .build();

        return friendshipRepository.save(accepted);
    }

    @Transactional
    public void rejectFriendRequest(UUID userId, UUID friendId) {
        Friendship friendship = friendshipRepository.findByUserIds(userId, friendId)
                .orElseThrow(() -> new RuntimeException("Friend request not found"));

        if (friendship.getRequestedBy().equals(userId)) {
            throw new RuntimeException("You cannot reject your own friend request");
        }

        friendshipRepository.delete(friendship.getId());
    }

    @Transactional
    public void removeFriend(UUID userId, UUID friendId) {
        friendshipRepository.deleteByUserIds(userId, friendId);
    }

    @Transactional
    public void blockUser(UUID userId, UUID userToBlockId) {
        Optional<Friendship> existing = friendshipRepository.findByUserIds(userId, userToBlockId);

        Friendship blocked = Friendship.builder()
                .id(existing.map(Friendship::getId).orElse(null))
                .userId(userId)
                .friendId(userToBlockId)
                .status(FriendshipStatus.BLOCKED)
                .requestedBy(userId)
                .requestedAt(LocalDateTime.now())
                .build();

        friendshipRepository.save(blocked);
    }

    public List<FriendProfile> getFriends(UUID userId) {
        return friendshipRepository.findAcceptedFriends(userId).stream()
                .map(f -> buildFriendProfile(userId, f))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    public List<FriendProfile> searchFriends(UUID userId, String query) {
        List<Friendship> friendships = friendshipRepository.findAcceptedFriends(userId);

        return friendships.stream()
                .map(f -> f.getUserId().equals(userId) ? f.getFriendId() : f.getUserId())
                .map(friendId -> userRepository.findById(friendId).orElse(null))
                .filter(Objects::nonNull)
                .filter(user -> user.getUsername().toLowerCase().contains(query.toLowerCase()) ||
                        user.getFullName().toLowerCase().contains(query.toLowerCase()))
                .map(user -> buildFriendProfileFromUser(userId, user, FriendshipStatus.ACCEPTED))
                .collect(Collectors.toList());
    }

    public List<FriendProfile> discoverUsers(UUID userId) {
        log.info("Discovering users for userId: {}", userId);
        try {
            List<UUID> excludeIds = new ArrayList<>();
            excludeIds.add(userId);

            List<Friendship> userRelations = friendshipRepository.findAllByUserId(userId);
            log.info("Found {} relations to exclude", userRelations.size());

            userRelations.forEach(f -> {
                excludeIds.add(f.getUserId().equals(userId) ? f.getFriendId() : f.getUserId());
            });

            List<User> allUsers = userRepository.findAll();
            log.info("Total users in system: {}", allUsers.size());

            return allUsers.stream()
                    .filter(u -> !excludeIds.contains(u.getId()))
                    .map(u -> {
                        try {
                            return buildFriendProfileFromUser(userId, u, FriendshipStatus.NONE);
                        } catch (Exception e) {
                            log.error("Error building profile for user {}: {}", u.getId(), e.getMessage());
                            return null;
                        }
                    })
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("Error in discoverUsers: ", e);
            throw e;
        }
    }

    public List<FriendProfile> getPendingRequests(UUID userId) {
        return friendshipRepository.findPendingRequests(userId).stream()
                .map(f -> buildFriendProfile(userId, f))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    public boolean areFriends(UUID userId1, UUID userId2) {
        return friendshipRepository.findByUserIds(userId1, userId2)
                .map(Friendship::isAccepted)
                .orElse(false);
    }

    public int getMutualFriendsCount(UUID userId, UUID otherUserId) {
        Set<UUID> userFriends = friendshipRepository.findAcceptedFriends(userId).stream()
                .map(f -> f.getUserId().equals(userId) ? f.getFriendId() : f.getUserId())
                .collect(Collectors.toSet());

        Set<UUID> otherUserFriends = friendshipRepository.findAcceptedFriends(otherUserId).stream()
                .map(f -> f.getUserId().equals(otherUserId) ? f.getFriendId() : f.getUserId())
                .collect(Collectors.toSet());

        userFriends.retainAll(otherUserFriends);
        return userFriends.size();
    }

    private FriendProfile buildFriendProfile(UUID currentUserId, Friendship friendship) {
        UUID friendId = friendship.getUserId().equals(currentUserId)
                ? friendship.getFriendId()
                : friendship.getUserId();

        User friend = userRepository.findById(friendId).orElse(null);
        if (friend == null)
            return null;

        return buildFriendProfileFromUser(currentUserId, friend, friendship.getStatus());
    }

}
